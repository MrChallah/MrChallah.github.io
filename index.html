<!DOCTYPE html><html><head><meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
<style>
html,body{margin:0;padding:0;background:transparent;color:#fff;font-family:sans-serif;}
#info{position:absolute;top:8px;left:8px;display:flex;flex-direction:column;gap:4px;}
.row{display:flex;align-items:center;font-size:15px;font-weight:500;text-shadow:0 0 4px #000,0 0 8px #000;}
.row i{width:18px;margin-right:6px;text-align:center;}
</style></head><body>

<div id="info">
  <div class="row"><i class="fa-regular fa-clock"></i><span id="time">--:--:--</span></div>
  <div class="row"><i class="fa-solid fa-location-dot"></i><span id="place">Waiting…</span></div>
  <div class="row"><i class="fa-solid fa-cloud"></i><span id="weather">--°C</span></div>
</div>

<script>
const placeEl = document.getElementById('place');
const weatherEl = document.getElementById('weather');
const OWM_KEY = '618628ae452ff89f0e4477fba20b9d5c';
const GOOGLE_GEO_KEY = 'AIzaSyBFwxZu_EqPgs7pEqk1uHn1f46F6vUoEFU';

function tick(){
  const now = new Date();
  const offset = now.getTimezoneOffset() / -60;
  const sign = offset > 0 ? '-' : '+';
  document.getElementById('time').textContent =
    `${now.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',second:'2-digit'})} GMT${sign}${Math.abs(offset)}`;
}
tick(); setInterval(tick, 1000);

async function reverseGeocode(lat, lon){
  const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en`);
  const geo = await res.json();
  const addr = geo.address;
  const parts = [
    addr.road || addr.suburb || "",
    addr.city || addr.town || addr.village || "",
    addr.state || "",
    addr.country || ""
  ].filter(Boolean);
  return parts.join(", ");
}

async function fetchWeather(lat, lon){
  const r = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&lang=en&appid=${OWM_KEY}`);
  const j = await r.json();
  const c = j.main.temp.toFixed(0);
  const f = (c * 9 / 5 + 32).toFixed(0);
  const desc = j.weather[0].description.replace(/\b\w/g, s => s.toUpperCase());
  weatherEl.textContent = `${c}°C | ${f}°F, ${desc}`;
}

// Method 1: Google Geolocation API (Enhanced)
async function getGoogleLocation(){
  const res = await fetch("https://www.googleapis.com/geolocation/v1/geolocate?key=" + GOOGLE_GEO_KEY, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ 
      considerIp: true,
      wifiAccessPoints: [], // Could be populated if available
      cellTowers: []        // Could be populated if available
    })
  });
  const data = await res.json();
  return {
    lat: data.location.lat,
    lon: data.location.lng,
    accuracy: data.accuracy || 'Unknown',
    source: "Google Geolocation"
  };
}

// Method 2: IPInfo.io (Often more accurate than basic IP geolocation)
async function getIPInfoLocation(){
  const res = await fetch('https://ipinfo.io/json');
  const data = await res.json();
  if (data.loc) {
    const [lat, lon] = data.loc.split(',').map(Number);
    return {
      lat,
      lon,
      city: data.city,
      region: data.region,
      country: data.country,
      source: "IPInfo.io"
    };
  }
  throw new Error('No location data from IPInfo');
}

// Method 3: IP-API.com (Another accurate service)
async function getIPAPILocation(){
  const res = await fetch('http://ip-api.com/json/?fields=status,lat,lon,city,regionName,country,isp');
  const data = await res.json();
  if (data.status === 'success') {
    return {
      lat: data.lat,
      lon: data.lon,
      city: data.city,
      region: data.regionName,
      country: data.country,
      isp: data.isp,
      source: "IP-API.com"
    };
  }
  throw new Error('No location data from IP-API');
}

// Method 4: FreeGeoIP
async function getFreeGeoIPLocation(){
  const res = await fetch('https://freegeoip.app/json/');
  const data = await res.json();
  return {
    lat: data.latitude,
    lon: data.longitude,
    city: data.city,
    region: data.region_name,
    country: data.country_name,
    source: "FreeGeoIP"
  };
}

// Enhanced location detection with multiple services
async function getEnhancedIPLocation() {
  const services = [
    getIPInfoLocation,      // Often most accurate
    getIPAPILocation,       // Good fallback
    getFreeGeoIPLocation,   // Alternative
    getGoogleLocation       // Google as final fallback
  ];
  
  let bestLocation = null;
  let allResults = [];
  
  // Try each service
  for (const service of services) {
    try {
      const result = await service();
      allResults.push(result);
      console.log(`${result.source}: ${result.lat}, ${result.lon}`);
      
      // Use the first successful result as primary
      if (!bestLocation) {
        bestLocation = result;
      }
    } catch (e) {
      console.log(`Service failed:`, e.message);
    }
  }
  
  // If we have multiple results, we could potentially average them
  // or use the one with best accuracy indicators
  if (allResults.length > 1) {
    console.log(`Got ${allResults.length} location sources, using: ${bestLocation.source}`);
  }
  
  return bestLocation;
}

// Try browser GPS first (if available), then enhanced IP location
function getBrowserGPS() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation not supported'));
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          lat: position.coords.latitude,
          lon: position.coords.longitude,
          accuracy: Math.round(position.coords.accuracy),
          source: `Browser GPS (±${Math.round(position.coords.accuracy)}m)`
        });
      },
      (error) => {
        reject(error);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 30000
      }
    );
  });
}

async function updateLocationAndWeather(){
  try {
    let locationData = null;
    
    // Try IRL Pro location data first
    if (window.locationData && window.locationData.latitude) {
      locationData = {
        lat: window.locationData.latitude,
        lon: window.locationData.longitude,
        source: "IRL Pro GPS"
      };
    }
    
    // Try browser GPS if no IRL Pro data
    if (!locationData) {
      try {
        locationData = await getBrowserGPS();
      } catch (gpsError) {
        console.log('Browser GPS failed, trying enhanced IP location...');
      }
    }
    
    // Use enhanced IP location as fallback
    if (!locationData) {
      placeEl.textContent = "Getting enhanced location...";
      locationData = await getEnhancedIPLocation();
    }
    
    // Update display
    if (locationData) {
      placeEl.textContent = "Loading location...";
      const label = await reverseGeocode(locationData.lat, locationData.lon);
      placeEl.textContent = label;
      fetchWeather(locationData.lat, locationData.lon);
      console.log(`Final location: ${locationData.source} - ${locationData.lat}, ${locationData.lon}`);
    }
    
  } catch (e) {
    placeEl.textContent = "Location N/A";
    weatherEl.textContent = "Weather N/A";
    console.error("All location methods failed:", e);
  }
}

setInterval(updateLocationAndWeather, 90000);
updateLocationAndWeather();
</script>
</body></html>
