<!DOCTYPE html><html><head><meta charset="utf-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
  <style>
  html,body{margin:0;padding:0;background:transparent;color:#fff;font-family:sans-serif;}
  #info{position:absolute;top:8px;left:8px;display:flex;flex-direction:column;gap:4px;}
  .row{display:flex;align-items:center;font-size:15px;font-weight:500;text-shadow:0 0 4px #000,0 0 8px #000;}
  .row i{width:18px;margin-right:6px;text-align:center;}
  #debug{position:absolute;top:8px;right:8px;font-size:10px;max-width:300px;background:rgba(0,0,0,0.8);padding:8px;border-radius:4px;color:#fff;white-space:pre-wrap;font-family:monospace;max-height:400px;overflow-y:auto;display:none;}
  .debug-button{position:absolute;bottom:8px;left:8px;background:rgba(255,0,0,0.7);color:#fff;padding:8px 12px;border:none;border-radius:4px;font-size:12px;cursor:pointer;z-index:1000;}
  .debug-button:hover{background:rgba(255,0,0,0.9);}
  #manual-gps{position:absolute;bottom:8px;right:8px;background:rgba(0,100,255,0.7);color:#fff;padding:8px 12px;border:none;border-radius:4px;font-size:12px;cursor:pointer;z-index:1000;}
  #manual-gps:hover{background:rgba(0,100,255,0.9);}
  </style></head><body>
  
  <div id="info">
    <div class="row"><i class="fa-regular fa-clock"></i><span id="time">--:--:--</span></div>
    <div class="row"><i class="fa-solid fa-location-dot"></i><span id="place">Getting GPS fix...</span></div>
    <div class="row"><i class="fa-solid fa-cloud-sun"></i><span id="weather">Loading...</span></div>
  </div>
  
  <div id="debug"></div>
  <button class="debug-button" onclick="toggleDebug()">Debug</button>
  <button id="manual-gps" onclick="injectTestGPS()">Test GPS</button>
  
  <script>
  // Debug system
  let debugMode = false;
  let lastDebugLog = [];
  const debugEl = document.getElementById('debug');
  
  function debugLog(msg) {
    const timestamp = new Date().toLocaleTimeString();
    const logMsg = `${timestamp}: ${msg}`;
    console.log(logMsg);
    lastDebugLog.push(logMsg);
    if (lastDebugLog.length > 50) lastDebugLog.shift();
    if (debugMode && debugEl) {
      debugEl.innerHTML = lastDebugLog.join('\n');
      debugEl.scrollTop = debugEl.scrollHeight;
    }
  }
  
  function toggleDebug() {
    debugMode = !debugMode;
    debugEl.style.display = debugMode ? 'block' : 'none';
    if (debugMode) debugEl.innerHTML = lastDebugLog.join('\n');
  }
  
  // GPS Detection System
  let currentLocation = { lat: null, lon: null, source: null, accuracy: null };
  let gpsWatchId = null;
  let irlProPollingInterval = null;
  let manualGPS = null;
  
  // Manual GPS injection for testing
  function injectTestGPS() {
    // Use a test location (Times Square, NYC)
    manualGPS = {
      lat: 40.7580,
      lon: -73.9855,
      accuracy: 5,
      source: 'Manual Test'
    };
    debugLog(`Manual GPS injected: ${manualGPS.lat}, ${manualGPS.lon}`);
    updateLocation(manualGPS);
  }
  
  // Comprehensive IRL Pro GPS detection
  function detectIRLProGPS() {
    debugLog('Starting comprehensive IRL Pro GPS detection...');
    
    // Method 1: Check for manual override first
    if (manualGPS) {
      debugLog(`Using manual GPS: ${manualGPS.lat}, ${manualGPS.lon}`);
      return manualGPS;
    }
    
    // Method 1.5: Check for intercepted GPS data
    if (window._interceptedLocation) {
      debugLog(`Using intercepted GPS: ${window._interceptedLocation.lat}, ${window._interceptedLocation.lon}`);
      return window._interceptedLocation;
    }
    
    // Method 2: Check all possible window objects
    const possibleSources = [
      'window.locationData',
      'window.irlpro',
      'window.irlPro', 
      'window.IRLPro',
      'window.streamingApp',
      'window.streaming',
      'window.gpsData',
      'window.location_data',
      'window.geolocation_data',
      'window.coordinates',
      'window.position',
      'window.currentPosition',
      'window.deviceLocation',
      'window.phoneLocation',
      'window.mobileLocation',
      'window.nativeGPS',
      'window.androidGPS',
      'window.iosGPS',
      'window.webviewGPS',
      'window.bridge',
      'window.nativeBridge',
      'window.mobileBridge',
      'window.appBridge',
      'window.webkit',
      'window.chrome',
      'window.external',
      'window.ReactNativeWebView',
      'window.flutter_inappwebview'
    ];
    
    for (let sourcePath of possibleSources) {
      try {
        let obj = window;
        const parts = sourcePath.split('.');
        
        for (let i = 1; i < parts.length; i++) {
          if (obj && typeof obj === 'object' && parts[i] in obj) {
            obj = obj[parts[i]];
          } else {
            obj = null;
            break;
          }
        }
        
        if (obj !== null) {
          debugLog(`Found object at ${sourcePath}: ${typeof obj}`);
          
          // Try to extract GPS data from the found object
          let gpsData = extractGPSFromObject(obj, sourcePath);
          if (gpsData) return gpsData;
        }
      } catch (e) {
        debugLog(`Error accessing ${sourcePath}: ${e.message}`);
      }
    }
    
    // Method 3: Check URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const lat = urlParams.get('lat') || urlParams.get('latitude');
    const lon = urlParams.get('lon') || urlParams.get('lng') || urlParams.get('longitude');
    
    if (lat && lon) {
      debugLog(`Found GPS in URL: ${lat}, ${lon}`);
      return {
        lat: parseFloat(lat),
        lon: parseFloat(lon),
        accuracy: 10,
        source: 'URL Parameters'
      };
    }
    
    // Method 4: Check localStorage/sessionStorage
    const storageKeys = ['gps', 'location', 'position', 'coordinates', 'lat_lon', 'geolocation'];
    for (let key of storageKeys) {
      try {
        let data = localStorage.getItem(key) || sessionStorage.getItem(key);
        if (data) {
          debugLog(`Found storage data for ${key}: ${data}`);
          let parsed = JSON.parse(data);
          let gpsData = extractGPSFromObject(parsed, `localStorage.${key}`);
          if (gpsData) return gpsData;
        }
      } catch (e) {
        debugLog(`Error reading storage ${key}: ${e.message}`);
      }
    }
    
    // Method 5: Check for Android WebView interfaces
    try {
      if (window.Android && typeof window.Android.getLocation === 'function') {
        debugLog('Found Android WebView interface');
        let location = window.Android.getLocation();
        if (location) {
          let gpsData = extractGPSFromObject(location, 'Android.getLocation()');
          if (gpsData) return gpsData;
        }
      }
    } catch (e) {
      debugLog(`Android interface error: ${e.message}`);
    }
    
    // Method 6: Check for iOS WebKit interfaces
    try {
      if (window.webkit && window.webkit.messageHandlers) {
        debugLog('Found iOS WebKit interface');
        for (let handler in window.webkit.messageHandlers) {
          debugLog(`Available iOS handler: ${handler}`);
        }
        
        // Try common handler names
        const handlers = ['location', 'gps', 'position', 'coordinates'];
        for (let handlerName of handlers) {
          if (window.webkit.messageHandlers[handlerName]) {
            debugLog(`Attempting to call iOS handler: ${handlerName}`);
            try {
              window.webkit.messageHandlers[handlerName].postMessage('getLocation');
            } catch (e) {
              debugLog(`Error calling iOS handler ${handlerName}: ${e.message}`);
            }
          }
        }
      }
    } catch (e) {
      debugLog(`iOS interface error: ${e.message}`);
    }
    
    // Method 7: Try evaluating possible JavaScript expressions that IRL Pro might expose
    const jsExpressions = [
      'location.latitude',
      'location.longitude', 
      'getCurrentLocation()',
      'getLocation()',
      'navigator.position',
      'device.location',
      'mobile.gps',
      'app.location',
      'irlpro.gps.lat',
      'irlpro.gps.lon',
      'streamingapp.location.lat',
      'streamingapp.location.lon'
    ];
    
    for (let expr of jsExpressions) {
      try {
        let result = eval(expr);
        if (result !== undefined && result !== null && !isNaN(parseFloat(result))) {
          debugLog(`Eval success: ${expr} = ${result}`);
          // Store for potential lat/lon pairing
          window[`eval_${expr.replace(/[^\w]/g, '_')}`] = result;
        }
      } catch (e) {
        // Silent fail for eval attempts
      }
    }
    
    // Method 8: Check all global variables for GPS-like data
    try {
      debugLog('Scanning all global variables for GPS data...');
      let gpsVars = [];
      
      for (let prop in window) {
        try {
          let value = window[prop];
          if (value && typeof value === 'object') {
            // Check if this object has GPS-like properties
            if (hasGPSProperties(value)) {
              debugLog(`Found GPS-like object: window.${prop}`);
              let gpsData = extractGPSFromObject(value, `window.${prop}`);
              if (gpsData) return gpsData;
            }
          } else if (typeof value === 'number') {
            // Check if this might be a coordinate
            if (isCoordinateValue(value)) {
              gpsVars.push({ name: prop, value: value });
            }
          }
        } catch (e) {
          // Skip properties that can't be accessed
        }
      }
      
      // Look for coordinate pairs in the GPS variables
      for (let i = 0; i < gpsVars.length; i++) {
        for (let j = i + 1; j < gpsVars.length; j++) {
          let var1 = gpsVars[i];
          let var2 = gpsVars[j];
          
          if (isLatLonPair(var1.value, var2.value)) {
            let lat = isLatitude(var1.value) ? var1.value : var2.value;
            let lon = isLatitude(var1.value) ? var2.value : var1.value;
            
            debugLog(`Found coordinate pair: ${var1.name}=${var1.value}, ${var2.name}=${var2.value}`);
            return {
              lat: lat,
              lon: lon,
              accuracy: 10,
              source: `Global vars: ${var1.name}, ${var2.name}`
            };
          }
        }
      }
    } catch (e) {
      debugLog(`Error scanning globals: ${e.message}`);
    }
    
    // Method 9: IRL Pro specific detection patterns
    try {
      // Check for IRL Pro specific patterns
      if (document.title.toLowerCase().includes('irl') || 
          window.location.href.toLowerCase().includes('irl') ||
          navigator.userAgent.toLowerCase().includes('irl')) {
        debugLog('Detected IRL Pro app context');
        
        // Try IRL Pro specific methods
        const irlMethods = [
          () => window.IRL && window.IRL.getLocation(),
          () => window.irl && window.irl.location,
          () => window.app && window.app.gps,
          () => window.streaming && window.streaming.location,
          () => document.querySelector('[data-gps]'),
          () => document.querySelector('[data-location]'),
          () => document.getElementById('gps-data'),
          () => document.getElementById('location-data')
        ];
        
        for (let method of irlMethods) {
          try {
            let result = method();
            if (result) {
              debugLog(`IRL Pro method found data: ${JSON.stringify(result)}`);
              let gpsData = extractGPSFromObject(result, 'IRL Pro method');
              if (gpsData) return gpsData;
            }
          } catch (e) {
            // Silent fail
          }
        }
      }
    } catch (e) {
      debugLog(`IRL Pro detection error: ${e.message}`);
    }
    
    // Method 10: Check document for hidden location data
    try {
      const hiddenElements = document.querySelectorAll('input[type="hidden"], meta, script');
      for (let element of hiddenElements) {
        let content = element.value || element.content || element.textContent || '';
        if (content && content.includes(',')) {
          // Try to parse as coordinates
          let coords = parseCoordinatesFromString(content);
          if (coords) {
            debugLog(`Found coordinates in hidden element: ${coords.lat}, ${coords.lon}`);
            return {
              lat: coords.lat,
              lon: coords.lon,
              accuracy: 10,
              source: 'Hidden DOM element'
            };
          }
        }
      }
    } catch (e) {
      debugLog(`DOM scan error: ${e.message}`);
    }
    
    debugLog('No GPS data found in any IRL Pro sources');
    return null;
  }
  
  function extractGPSFromObject(obj, sourceName) {
    if (!obj) return null;
    
    try {
      // Direct lat/lon properties
      if (obj.lat !== undefined && obj.lon !== undefined) {
        debugLog(`Found GPS in ${sourceName}: lat=${obj.lat}, lon=${obj.lon}`);
        return {
          lat: parseFloat(obj.lat),
          lon: parseFloat(obj.lon),
          accuracy: obj.accuracy || 10,
          source: sourceName
        };
      }
      
      if (obj.latitude !== undefined && obj.longitude !== undefined) {
        debugLog(`Found GPS in ${sourceName}: lat=${obj.latitude}, lon=${obj.longitude}`);
        return {
          lat: parseFloat(obj.latitude),
          lon: parseFloat(obj.longitude),
          accuracy: obj.accuracy || 10,
          source: sourceName
        };
      }
      
      // Nested coordinates
      if (obj.coords) {
        return extractGPSFromObject(obj.coords, `${sourceName}.coords`);
      }
      
      if (obj.position) {
        return extractGPSFromObject(obj.position, `${sourceName}.position`);
      }
      
      if (obj.location) {
        return extractGPSFromObject(obj.location, `${sourceName}.location`);
      }
      
      // Array format [lat, lon]
      if (Array.isArray(obj) && obj.length >= 2) {
        let lat = parseFloat(obj[0]);
        let lon = parseFloat(obj[1]);
        if (!isNaN(lat) && !isNaN(lon)) {
          debugLog(`Found GPS array in ${sourceName}: [${lat}, ${lon}]`);
          return {
            lat: lat,
            lon: lon,
            accuracy: 10,
            source: sourceName
          };
        }
      }
      
      // String format "lat,lon"
      if (typeof obj === 'string' && obj.includes(',')) {
        let parts = obj.split(',');
        if (parts.length >= 2) {
          let lat = parseFloat(parts[0].trim());
          let lon = parseFloat(parts[1].trim());
          if (!isNaN(lat) && !isNaN(lon)) {
            debugLog(`Found GPS string in ${sourceName}: "${obj}"`);
            return {
              lat: lat,
              lon: lon,
              accuracy: 10,
              source: sourceName
            };
          }
        }
      }
      
    } catch (e) {
      debugLog(`Error extracting GPS from ${sourceName}: ${e.message}`);
    }
    
    return null;
  }
  
  // Helper functions for GPS detection
  function hasGPSProperties(obj) {
    if (!obj || typeof obj !== 'object') return false;
    
    const gpsProps = ['lat', 'lon', 'latitude', 'longitude', 'coords', 'position', 'location', 'gps'];
    return gpsProps.some(prop => prop in obj);
  }
  
  function isCoordinateValue(value) {
    if (typeof value !== 'number' || isNaN(value)) return false;
    
    // Check if it's in valid coordinate range
    return (value >= -180 && value <= 180);
  }
  
  function isLatitude(value) {
    return typeof value === 'number' && value >= -90 && value <= 90;
  }
  
  function isLongitude(value) {
    return typeof value === 'number' && value >= -180 && value <= 180;
  }
  
  function isLatLonPair(val1, val2) {
    return (isLatitude(val1) && isLongitude(val2)) || 
           (isLatitude(val2) && isLongitude(val1));
  }
  
  function parseCoordinatesFromString(str) {
    if (!str || typeof str !== 'string') return null;
    
    // Try various coordinate formats
    const patterns = [
      /(-?\d+\.?\d*),\s*(-?\d+\.?\d*)/, // "lat,lon" or "lat, lon"
      /lat[:\s=]*(-?\d+\.?\d*)[,\s]+lon[:\s=]*(-?\d+\.?\d*)/i, // "lat:40.7, lon:-73.9"
      /latitude[:\s=]*(-?\d+\.?\d*)[,\s]+longitude[:\s=]*(-?\d+\.?\d*)/i, // full names
      /\[(-?\d+\.?\d*),\s*(-?\d+\.?\d*)\]/ // [lat,lon]
    ];
    
    for (let pattern of patterns) {
      let match = str.match(pattern);
      if (match) {
        let lat = parseFloat(match[1]);
        let lon = parseFloat(match[2]);
        
        if (isLatitude(lat) && isLongitude(lon)) {
          return { lat: lat, lon: lon };
        }
        
        // Try swapped order
        if (isLatitude(lon) && isLongitude(lat)) {
          return { lat: lon, lon: lat };
        }
      }
    }
    
    return null;
  }
  
  // Listen for postMessage events (IRL Pro might send data this way)
  window.addEventListener('message', function(event) {
    debugLog(`Received postMessage from ${event.origin}: ${JSON.stringify(event.data)}`);
    
    if (event.data && typeof event.data === 'object') {
      let gpsData = extractGPSFromObject(event.data, 'postMessage');
      if (gpsData) {
        debugLog(`GPS data received via postMessage: ${gpsData.lat}, ${gpsData.lon}`);
        updateLocation(gpsData);
      }
    }
  });
  
  // Start IRL Pro polling
  function startIRLProPolling() {
    if (irlProPollingInterval) clearInterval(irlProPollingInterval);
    
    // Store initial window properties to detect new ones
    let initialProps = new Set(Object.getOwnPropertyNames(window));
    
    irlProPollingInterval = setInterval(() => {
      // Check for new window properties
      let currentProps = Object.getOwnPropertyNames(window);
      for (let prop of currentProps) {
        if (!initialProps.has(prop)) {
          initialProps.add(prop);
          try {
            let value = window[prop];
            if (value && typeof value === 'object' && hasGPSProperties(value)) {
              debugLog(`New GPS-like property detected: window.${prop}`);
              let gpsData = extractGPSFromObject(value, `new property: ${prop}`);
              if (gpsData && (gpsData.lat !== currentLocation.lat || gpsData.lon !== currentLocation.lon)) {
                debugLog(`New GPS data from property ${prop}: ${gpsData.lat}, ${gpsData.lon}`);
                updateLocation(gpsData);
                return;
              }
            }
          } catch (e) {
            // Ignore
          }
        }
      }
      
      // Regular polling of existing sources
      let gpsData = detectIRLProGPS();
      if (gpsData && (gpsData.lat !== currentLocation.lat || gpsData.lon !== currentLocation.lon)) {
        debugLog(`Updated GPS data from IRL Pro: ${gpsData.lat}, ${gpsData.lon} (${gpsData.source})`);
        updateLocation(gpsData);
      }
    }, 2000); // Poll every 2 seconds
  }
  
  // Monkey-patch geolocation functions to intercept IRL Pro calls
  function setupGeolocationInterception() {
    if (navigator.geolocation && navigator.geolocation.getCurrentPosition) {
      const originalGetCurrentPosition = navigator.geolocation.getCurrentPosition;
      
      navigator.geolocation.getCurrentPosition = function(success, error, options) {
        debugLog('Intercepted geolocation.getCurrentPosition call');
        
        // Call original with our own success handler
        return originalGetCurrentPosition.call(this, function(position) {
          debugLog(`Intercepted GPS result: ${position.coords.latitude}, ${position.coords.longitude}`);
          // Store this for our use
          window._interceptedLocation = {
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: position.coords.accuracy,
            source: 'Intercepted Geolocation'
          };
          
          // Call original success handler
          if (success) success(position);
        }, error, options);
      };
    }
    
    // Also intercept watchPosition
    if (navigator.geolocation && navigator.geolocation.watchPosition) {
      const originalWatchPosition = navigator.geolocation.watchPosition;
      
      navigator.geolocation.watchPosition = function(success, error, options) {
        debugLog('Intercepted geolocation.watchPosition call');
        
        return originalWatchPosition.call(this, function(position) {
          debugLog(`Intercepted watch GPS result: ${position.coords.latitude}, ${position.coords.longitude}`);
          window._interceptedLocation = {
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: position.coords.accuracy,
            source: 'Intercepted Watch Position'
          };
          
          if (success) success(position);
        }, error, options);
      };
    }
  }
  
  // Method 2: Try browser GPS
  function getBrowserGPS() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation not supported'));
        return;
      }

      document.getElementById('place').textContent = "Getting GPS fix...";
      debugLog('Attempting browser GPS...');
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          debugLog(`Browser GPS success: ${position.coords.latitude}, ${position.coords.longitude}`);
          resolve({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: Math.round(position.coords.accuracy),
            source: `Browser GPS (±${Math.round(position.coords.accuracy)}m)`
          });
        },
        (error) => {
          debugLog(`Browser GPS error: ${error.message}`);
          reject(error);
        },
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 60000
        }
      );
    });
  }

  // Method 3: IP geolocation fallback
  async function getIPLocation() {
    try {
      debugLog('Attempting IP geolocation...');
      const response = await fetch('https://ipapi.co/json/');
      const data = await response.json();
      
      if (data.latitude && data.longitude) {
        debugLog(`IP location success: ${data.latitude}, ${data.longitude}`);
        return {
          lat: data.latitude,
          lon: data.longitude,
          accuracy: 50000,
          source: `IP Location - ${data.city}, ${data.country_name}`
        };
      }
      throw new Error('No coordinates in IP response');
    } catch (error) {
      debugLog(`IP geolocation failed: ${error.message}`);
      throw error;
    }
  }

  // Update location and weather
  function updateLocation(location) {
    if (!location.lat || !location.lon) return;
    
    currentLocation = location;
    debugLog(`Location updated: ${location.source} - ${location.lat}, ${location.lon}`);
    
    // Update place display
    document.getElementById('place').textContent = location.source;
    
    // Get weather for this location
    getWeather(location.lat, location.lon);
  }

  // Weather function
  async function getWeather(lat, lon) {
    try {
      debugLog(`Getting weather for ${lat}, ${lon}`);
      const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=YOUR_API_KEY&units=metric`);
      const data = await response.json();
      
      if (data.main && data.weather && data.weather[0]) {
        const temp = Math.round(data.main.temp);
        const desc = data.weather[0].description;
        document.getElementById('weather').textContent = `${temp}°C ${desc}`;
        debugLog(`Weather updated: ${temp}°C ${desc}`);
      } else {
        document.getElementById('weather').textContent = 'Weather unavailable';
      }
    } catch (error) {
      debugLog(`Weather error: ${error.message}`);
      document.getElementById('weather').textContent = 'Weather error';
    }
  }

  // Main GPS acquisition function
  async function getLocation() {
    debugLog('=== Starting GPS acquisition ===');
    
    // Try IRL Pro first
    let irlLocation = detectIRLProGPS();
    if (irlLocation) {
      updateLocation(irlLocation);
      return;
    }
    
    // If no IRL Pro data, try browser GPS
    try {
      let browserLocation = await getBrowserGPS();
      updateLocation(browserLocation);
      return;
    } catch (error) {
      debugLog(`Browser GPS failed: ${error.message}`);
    }
    
    // Fall back to IP location
    try {
      let ipLocation = await getIPLocation();
      updateLocation(ipLocation);
    } catch (error) {
      debugLog(`All location methods failed: ${error.message}`);
      document.getElementById('place').textContent = 'Location unavailable';
    }
  }

  // Time function
  function updateTime() {
    const now = new Date();
    const timeStr = now.toLocaleTimeString();
    document.getElementById('time').textContent = timeStr;
  }

  // Auto-enable debug on URL parameter
  if (window.location.search.includes('debug=1')) {
    debugMode = true;
    debugEl.style.display = 'block';
    debugLog('Debug mode auto-enabled via URL parameter');
  }

  // Initialize
  debugLog('=== IRL Pro GPS Overlay Initialized ===');
  debugLog('Mobile debug controls: Triple-tap screen or long-press time');
  debugLog(`User agent: ${navigator.userAgent}`);
  debugLog(`Location: ${window.location.href}`);
  
  // Check if we're in IRL Pro or similar app
  if (navigator.userAgent.includes('wv') || window.Android || window.webkit) {
    debugLog('Detected WebView environment - likely in mobile app');
  }
  
  updateTime();
  setInterval(updateTime, 1000);
  
  setupGeolocationInterception();
  getLocation();
  startIRLProPolling();
  
  // Mobile-friendly debug controls
  let tapCount = 0;
  let tapTimer = null;
  
  // Triple-tap to toggle debug
  document.addEventListener('touchstart', (e) => {
    tapCount++;
    if (tapTimer) clearTimeout(tapTimer);
    
    if (tapCount === 3) {
      toggleDebug();
      tapCount = 0;
    } else {
      tapTimer = setTimeout(() => tapCount = 0, 500);
    }
  });
  
  // Long-press time to toggle debug
  let pressTimer = null;
  const timeEl = document.getElementById('time');
  
  timeEl.addEventListener('touchstart', (e) => {
    pressTimer = setTimeout(() => {
      toggleDebug();
      timeEl.style.background = debugMode ? 'red' : '';
    }, 2000);
  });
  
  timeEl.addEventListener('touchend', () => {
    if (pressTimer) clearTimeout(pressTimer);
  });
  
  // Global functions for manual testing
  window.injectGPS = function(lat, lon, source) {
    manualGPS = { lat: parseFloat(lat), lon: parseFloat(lon), accuracy: 5, source: source || 'Manual' };
    debugLog(`GPS injected via console: ${lat}, ${lon}`);
    updateLocation(manualGPS);
  };
  
  window.testIRLPro = function() {
    // Simulate IRL Pro data for testing
    window.locationData = { lat: 40.7580, lon: -73.9855 };
    debugLog('Test IRL Pro data injected into window.locationData');
    getLocation();
  };
  
  debugLog('Debug controls: toggleDebug(), injectGPS(lat,lon), testIRLPro()');
  debugLog('Instructions: Use triple-tap, long-press time, or add ?debug=1 to URL');
  </script>
  </body></html>
