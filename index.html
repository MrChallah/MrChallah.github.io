<!DOCTYPE html><html><head><meta charset="utf-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
  <style>
  html,body{margin:0;padding:0;background:transparent;color:#fff;font-family:sans-serif;}
  #info{position:absolute;top:8px;left:8px;display:flex;flex-direction:column;gap:4px;}
  .row{display:flex;align-items:center;font-size:15px;font-weight:500;text-shadow:0 0 4px #000,0 0 8px #000;}
  .row i{width:18px;margin-right:6px;text-align:center;}
  </style></head><body>
  
  <div id="info">
    <div class="row"><i class="fa-regular fa-clock"></i><span id="time">--:--:--</span></div>
    <div class="row"><i class="fa-solid fa-location-dot"></i><span id="place">Waiting…</span></div>
    <div class="row"><i class="fa-solid fa-cloud"></i><span id="weather">--°C</span></div>
  </div>
  
  <script>
  const placeEl = document.getElementById('place');
  const weatherEl = document.getElementById('weather');
  const OWM_KEY = '618628ae452ff89f0e4477fba20b9d5c';
  const GOOGLE_GEO_KEY = 'AIzaSyBFwxZu_EqPgs7pEqk1uHn1f46F6vUoEFU';
  
  function tick(){
    const now = new Date();
    const offset = now.getTimezoneOffset() / -60;
    const sign = offset > 0 ? '-' : '+';
    document.getElementById('time').textContent =
      `${now.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',second:'2-digit'})} GMT${sign}${Math.abs(offset)}`;
  }
  tick(); setInterval(tick, 1000);
  
  async function reverseGeocode(lat, lon){
    const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en`);
    const geo = await res.json();
    const addr = geo.address;
    const parts = [
      addr.road || addr.suburb || "",
      addr.city || addr.town || addr.village || "",
      addr.state || "",
      addr.country || ""
    ].filter(Boolean);
    return parts.join(", ");
  }
  
  async function fetchWeather(lat, lon){
    const r = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&lang=en&appid=${OWM_KEY}`);
    const j = await r.json();
    const c = j.main.temp.toFixed(0);
    const f = (c * 9 / 5 + 32).toFixed(0);
    const desc = j.weather[0].description.replace(/\b\w/g, s => s.toUpperCase());
    weatherEl.textContent = `${c}°C | ${f}°F, ${desc}`;
  }
  
  // Method 1: Try IRL Pro location data
  function getIRLProLocation() {
    // List of all possible location data sources to try
    const locationSources = [
      // Direct window properties
      () => window.locationData,
      () => window.irlpro,
      () => window.irlPro,
      () => window.IRLPro,
      () => window.streamingApp,
      () => window.streaming,
      () => window.gpsData,
      () => window.location_data,
      () => window.geolocation_data,
      () => window.coordinates,
      () => window.position,
      () => window.currentPosition,
      () => window.deviceLocation,
      () => window.phoneLocation,
      () => window.mobileLocation,
      () => window.nativeGPS,
      () => window.androidGPS,
      () => window.iosGPS,
      () => window.webviewGPS,
      () => window.bridge,
      () => window.nativeBridge,
      () => window.mobileBridge,
      () => window.appBridge,
      () => window.webkit,
      () => window.chrome,
      () => window.external,
      () => window.ReactNativeWebView,
      () => window.flutter_inappwebview,
      
      // Function calls
      () => {
        try {
          if (typeof window.getCurrentLocation === 'function') {
            return window.getCurrentLocation();
          }
        } catch (e) { return null; }
      },
      () => {
        try {
          if (typeof window.getLocation === 'function') {
            return window.getLocation();
          }
        } catch (e) { return null; }
      },
      
      // Nested properties
      () => {
        try {
          if (window.location && typeof window.location.latitude !== 'undefined') {
            return { latitude: window.location.latitude, longitude: window.location.longitude };
          }
        } catch (e) { return null; }
      },
      () => {
        try {
          if (window.navigator && window.navigator.position) {
            return window.navigator.position;
          }
        } catch (e) { return null; }
      },
      () => {
        try {
          if (window.device && window.device.location) {
            return window.device.location;
          }
        } catch (e) { return null; }
      },
      () => {
        try {
          if (window.mobile && window.mobile.gps) {
            return window.mobile.gps;
          }
        } catch (e) { return null; }
      },
      () => {
        try {
          if (window.app && window.app.location) {
            return window.app.location;
          }
        } catch (e) { return null; }
      },
      () => {
        try {
          if (window.irlpro && window.irlpro.gps) {
            return { 
              latitude: window.irlpro.gps.lat, 
              longitude: window.irlpro.gps.lon 
            };
          }
        } catch (e) { return null; }
      },
      () => {
        try {
          if (window.streamingapp && window.streamingapp.location) {
            return { 
              latitude: window.streamingapp.location.lat, 
              longitude: window.streamingapp.location.lon 
            };
          }
        } catch (e) { return null; }
      }
    ];

    // Try each source until we find valid GPS data
    for (let i = 0; i < locationSources.length; i++) {
      try {
        const data = locationSources[i]();
        
        if (data && typeof data === 'object') {
          // Check various property name combinations
          const lat = data.latitude || data.lat || data.Latitude || data.LAT;
          const lon = data.longitude || data.lon || data.lng || data.Longitude || data.LON || data.LNG;
          
          if (typeof lat === 'number' && typeof lon === 'number' && 
              !isNaN(lat) && !isNaN(lon) && 
              lat >= -90 && lat <= 90 && 
              lon >= -180 && lon <= 180) {
            
            console.log(`Found GPS data from source ${i}:`, data);
            return {
              lat: lat,
              lon: lon,
              source: `IRL Pro GPS (method ${i})`
            };
          }
        }
      } catch (e) {
        // Silently continue to next source
        continue;
      }
    }
    
    return null;
  }
  
  // Method 2: Try browser GPS
  function getBrowserGPS() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation not supported'));
        return;
      }
  
      placeEl.textContent = "Getting GPS fix...";
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          resolve({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: Math.round(position.coords.accuracy),
            source: `Browser GPS (±${Math.round(position.coords.accuracy)}m)`
          });
        },
        (error) => {
          console.log('GPS Error:', error.message);
          reject(error);
        },
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 30000
        }
      );
    });
  }
  
  // Method 3: Fallback to IP location
  async function getLocationFromGoogle(){
    const res = await fetch("https://www.googleapis.com/geolocation/v1/geolocate?key=" + GOOGLE_GEO_KEY, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ considerIp: true })
    });
    const data = await res.json();
    return {
      lat: data.location.lat,
      lon: data.location.lng,
      source: "IP Location"
    };
  }
  
  async function updateLocationAndWeather(){
    try {
      let locationData = null;
      
      // Try Method 1: IRL Pro location data
      locationData = getIRLProLocation();
      if (locationData) {
        console.log('Using IRL Pro location');
      }
      
      // Try Method 2: Browser GPS (if no IRL Pro data)
      if (!locationData) {
        try {
          locationData = await getBrowserGPS();
          console.log('Using Browser GPS');
        } catch (gpsError) {
          console.log('Browser GPS failed:', gpsError.message);
        }
      }
      
      // Try Method 3: IP location fallback
      if (!locationData) {
        placeEl.textContent = "Using IP location...";
        locationData = await getLocationFromGoogle();
        console.log('Using IP location');
      }
      
      // Update the display
      if (locationData) {
        placeEl.textContent = "Loading location...";
        const label = await reverseGeocode(locationData.lat, locationData.lon);
        placeEl.textContent = label;
        fetchWeather(locationData.lat, locationData.lon);
        console.log(`${locationData.source}: ${locationData.lat}, ${locationData.lon}`);
      }
      
    } catch (e) {
      placeEl.textContent = "Location N/A";
      weatherEl.textContent = "Weather N/A";
      console.error("Failed to get location or weather:", e);
    }
  }
  
  setInterval(updateLocationAndWeather, 90000);
  updateLocationAndWeather();
  </script>
  </body></html>
