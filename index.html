<!DOCTYPE html><html><head><meta charset="utf-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
  <style>
  html,body{margin:0;padding:0;background:transparent;color:#fff;font-family:sans-serif;}
  #info{position:absolute;top:8px;left:8px;display:flex;flex-direction:column;gap:4px;}
  .row{display:flex;align-items:center;font-size:15px;font-weight:500;text-shadow:0 0 4px #000,0 0 8px #000;}
  .row i{width:18px;margin-right:6px;text-align:center;}
  #debug{position:absolute;top:8px;right:8px;font-size:10px;max-width:300px;background:rgba(0,0,0,0.7);padding:4px;border-radius:4px;display:none;}
  </style></head><body>
  
  <div id="info">
    <div class="row"><i class="fa-regular fa-clock"></i><span id="time">--:--:--</span></div>
    <div class="row"><i class="fa-solid fa-location-dot"></i><span id="place">Waiting…</span></div>
    <div class="row"><i class="fa-solid fa-cloud"></i><span id="weather">--°C</span></div>
  </div>
  
  <div id="debug"></div>
  
  <script>
  const placeEl = document.getElementById('place');
  const weatherEl = document.getElementById('weather');
  const debugEl = document.getElementById('debug');
  const OWM_KEY = '618628ae452ff89f0e4477fba20b9d5c';
  const GOOGLE_GEO_KEY = 'AIzaSyBFwxZu_EqPgs7pEqk1uHn1f46F6vUoEFU';
  
  let debugMode = false;
  let lastDebugLog = [];
  
  function debugLog(message) {
    console.log(message);
    lastDebugLog.push(new Date().toLocaleTimeString() + ': ' + message);
    if (lastDebugLog.length > 10) lastDebugLog.shift();
    if (debugMode) {
      debugEl.style.display = 'block';
      debugEl.innerHTML = lastDebugLog.join('<br>');
    }
  }
  
  // Toggle debug mode with Alt+D
  document.addEventListener('keydown', (e) => {
    if (e.altKey && e.key === 'd') {
      debugMode = !debugMode;
      debugEl.style.display = debugMode ? 'block' : 'none';
      if (debugMode) debugEl.innerHTML = lastDebugLog.join('<br>');
    }
  });
  
  function tick(){
    const now = new Date();
    const offset = now.getTimezoneOffset() / -60;
    const sign = offset > 0 ? '-' : '+';
    document.getElementById('time').textContent =
      `${now.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',second:'2-digit'})} GMT${sign}${Math.abs(offset)}`;
  }
  tick(); setInterval(tick, 1000);
  
  async function reverseGeocode(lat, lon){
    const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en`);
    const geo = await res.json();
    const addr = geo.address;
    const parts = [
      addr.road || addr.suburb || "",
      addr.city || addr.town || addr.village || "",
      addr.state || "",
      addr.country || ""
    ].filter(Boolean);
    return parts.join(", ");
  }
  
  async function fetchWeather(lat, lon){
    const r = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&lang=en&appid=${OWM_KEY}`);
    const j = await r.json();
    const c = j.main.temp.toFixed(0);
    const f = (c * 9 / 5 + 32).toFixed(0);
    const desc = j.weather[0].description.replace(/\b\w/g, s => s.toUpperCase());
    weatherEl.textContent = `${c}°C | ${f}°F, ${desc}`;
  }
  
  // Deep scan for any GPS-related data in the global scope
  function scanGlobalScope() {
    const found = {};
    const keywords = ['location', 'gps', 'geo', 'position', 'coord', 'lat', 'lng', 'lon'];
    
    // Scan all window properties
    for (const prop in window) {
      if (keywords.some(keyword => prop.toLowerCase().includes(keyword))) {
        try {
          const value = window[prop];
          if (value && typeof value === 'object') {
            found[prop] = value;
          }
        } catch (e) {
          // Some properties might throw errors when accessed
        }
      }
    }
    
    return found;
  }
  
  // Check DOM for hidden GPS data
  function scanDOMForGPS() {
    const elements = document.querySelectorAll('[data-lat], [data-lng], [data-lon], [data-latitude], [data-longitude], [data-gps], [data-location]');
    const found = [];
    
    elements.forEach(el => {
      const data = {};
      ['lat', 'lng', 'lon', 'latitude', 'longitude', 'gps', 'location'].forEach(attr => {
        const value = el.dataset[attr];
        if (value) data[attr] = value;
      });
      if (Object.keys(data).length > 0) found.push(data);
    });
    
    return found;
  }
  
  // Method 1: Enhanced IRL Pro location data detection
  function getIRLProLocation() {
    debugLog('Scanning for IRL Pro GPS data...');
    
    // Try multiple possible ways IRL Pro might expose location data
    const possibleSources = [
      // Original attempt
      window.locationData,
      
      // Common patterns for streaming apps
      window.irlpro?.location,
      window.irlpro?.gps,
      window.irlpro?.coords,
      window.streamingApp?.location,
      window.gpsData,
      window.location_data,
      window.currentLocation,
      window.coords,
      window.coordinates,
      
      // Check for URL parameters (some apps pass data this way)
      (() => {
        const params = new URLSearchParams(window.location.search);
        const lat = params.get('lat') || params.get('latitude');
        const lon = params.get('lon') || params.get('lng') || params.get('longitude');
        if (lat && lon) {
          debugLog(`Found GPS in URL params: ${lat}, ${lon}`);
          return { latitude: parseFloat(lat), longitude: parseFloat(lon) };
        }
        return null;
      })(),
      
      // Check localStorage (some apps store location here)
      (() => {
        try {
          const keys = ['gpsLocation', 'currentLocation', 'location', 'coords', 'position'];
          for (const key of keys) {
            const stored = localStorage.getItem(key);
            if (stored) {
              const parsed = JSON.parse(stored);
              if (parsed && (parsed.latitude || parsed.lat) && (parsed.longitude || parsed.lon || parsed.lng)) {
                debugLog(`Found GPS in localStorage[${key}]: ${JSON.stringify(parsed)}`);
                return parsed;
              }
            }
          }
        } catch (e) {
          debugLog(`localStorage scan error: ${e.message}`);
        }
        return null;
      })(),
      
      // Check sessionStorage
      (() => {
        try {
          const keys = ['gpsLocation', 'currentLocation', 'location', 'coords', 'position'];
          for (const key of keys) {
            const stored = sessionStorage.getItem(key);
            if (stored) {
              const parsed = JSON.parse(stored);
              if (parsed && (parsed.latitude || parsed.lat) && (parsed.longitude || parsed.lon || parsed.lng)) {
                debugLog(`Found GPS in sessionStorage[${key}]: ${JSON.stringify(parsed)}`);
                return parsed;
              }
            }
          }
        } catch (e) {
          debugLog(`sessionStorage scan error: ${e.message}`);
        }
        return null;
      })(),
      
      // Check if there's a global GPS object
      window.GPS,
      window.gps,
      window.GEO,
      window.geo,
      window.LOCATION,
      window.COORDS,
      
      // Check for Android WebView interface
      window.Android?.getLocation ? (() => {
        try {
          const loc = window.Android.getLocation();
          debugLog(`Android interface returned: ${loc}`);
          return typeof loc === 'string' ? JSON.parse(loc) : loc;
        } catch (e) {
          debugLog(`Android interface error: ${e.message}`);
          return null;
        }
      })() : null,
      
      // Check for iOS WebKit message handlers
      window.webkit?.messageHandlers?.locationHandler ? (() => {
        try {
          debugLog('Found iOS WebKit locationHandler');
          return window.webkit.messageHandlers.locationHandler.postMessage('getLocation');
        } catch (e) {
          debugLog(`iOS WebKit error: ${e.message}`);
          return null;
        }
      })() : null,
      
      // Manual injection point for testing
      window.manualGPS,
      
      // Check global scope scan results
      ...Object.values(scanGlobalScope()),
      
      // Check DOM for GPS data
      ...scanDOMForGPS()
    ];
    
    debugLog(`Checking ${possibleSources.filter(s => s !== null).length} potential GPS sources`);
    
    for (let i = 0; i < possibleSources.length; i++) {
      const source = possibleSources[i];
      if (source && typeof source === 'object' && 
          (source.latitude || source.lat) && 
          (source.longitude || source.lon || source.lng)) {
        
        // Normalize the format
        const lat = source.latitude || source.lat;
        const lon = source.longitude || source.lon || source.lng;
        
        if (typeof lat === 'number' && typeof lon === 'number' && 
            lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
          debugLog(`GPS found in source ${i}: ${lat}, ${lon}`);
          return {
            lat: lat,
            lon: lon,
            source: "IRL Pro GPS"
          };
        } else {
          debugLog(`Invalid coordinates in source ${i}: lat=${lat}, lon=${lon}`);
        }
      }
    }
    
    debugLog('No valid GPS data found in any source');
    return null;
  }
  
  // Method 2: Try browser GPS
  function getBrowserGPS() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation not supported'));
        return;
      }
  
      placeEl.textContent = "Getting GPS fix...";
      debugLog('Attempting browser GPS...');
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          debugLog(`Browser GPS success: ${position.coords.latitude}, ${position.coords.longitude}`);
          resolve({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: Math.round(position.coords.accuracy),
            source: `Browser GPS (±${Math.round(position.coords.accuracy)}m)`
          });
        },
        (error) => {
          debugLog(`Browser GPS error: ${error.message}`);
          reject(error);
        },
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 30000
        }
      );
    });
  }
  
  // Method 3: Fallback to IP location
  async function getLocationFromGoogle(){
    debugLog('Using IP geolocation fallback...');
    const res = await fetch("https://www.googleapis.com/geolocation/v1/geolocate?key=" + GOOGLE_GEO_KEY, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ considerIp: true })
    });
    const data = await res.json();
    debugLog(`IP location: ${data.location.lat}, ${data.location.lng}`);
    return {
      lat: data.location.lat,
      lon: data.location.lng,
      source: "IP Location"
    };
  }
  
  // Add listeners for potential runtime location updates
  function setupLocationListeners() {
    // Listen for custom events that IRL Pro might dispatch
    const eventNames = ['locationUpdate', 'gpsUpdate', 'positionUpdate', 'irlLocationUpdate', 'coordsUpdate'];
    eventNames.forEach(eventName => {
      window.addEventListener(eventName, (event) => {
        debugLog(`Received event ${eventName}: ${JSON.stringify(event.detail)}`);
        if (event.detail && event.detail.latitude && event.detail.longitude) {
          const locationData = {
            lat: event.detail.latitude,
            lon: event.detail.longitude,
            source: "IRL Pro Event"
          };
          updateLocationAndWeatherWithData(locationData);
        }
      });
    });
    
    // Watch for changes in potential GPS sources
    let lastLocationCheck = null;
    setInterval(() => {
      const current = JSON.stringify(getIRLProLocation());
      if (current !== lastLocationCheck && current !== 'null') {
        lastLocationCheck = current;
        debugLog('GPS data changed, updating...');
        updateLocationAndWeather();
      }
    }, 2000); // Check every 2 seconds
    
    // Watch for new global variables
    const originalKeys = new Set(Object.keys(window));
    setInterval(() => {
      const newKeys = Object.keys(window).filter(key => !originalKeys.has(key));
      if (newKeys.length > 0) {
        debugLog(`New global variables detected: ${newKeys.join(', ')}`);
        newKeys.forEach(key => originalKeys.add(key));
      }
    }, 5000);
  }
  
  async function updateLocationAndWeatherWithData(locationData) {
    try {
      if (locationData) {
        placeEl.textContent = "Loading location...";
        const label = await reverseGeocode(locationData.lat, locationData.lon);
        placeEl.textContent = label;
        fetchWeather(locationData.lat, locationData.lon);
        debugLog(`Location updated: ${locationData.source} - ${locationData.lat}, ${locationData.lon}`);
      }
    } catch (e) {
      debugLog(`Failed to update location: ${e.message}`);
    }
  }
  
  async function updateLocationAndWeather(){
    try {
      let locationData = null;
      
      // Try Method 1: IRL Pro location data (with enhanced detection)
      locationData = getIRLProLocation();
      if (locationData) {
        debugLog('Using IRL Pro location');
        await updateLocationAndWeatherWithData(locationData);
        return;
      }
      
      // Try Method 2: Browser GPS (if no IRL Pro data)
      try {
        locationData = await getBrowserGPS();
        debugLog('Using Browser GPS');
        await updateLocationAndWeatherWithData(locationData);
        return;
      } catch (gpsError) {
        debugLog(`Browser GPS failed: ${gpsError.message}`);
      }
      
      // Try Method 3: IP location fallback
      placeEl.textContent = "Using IP location...";
      locationData = await getLocationFromGoogle();
      debugLog('Using IP location');
      await updateLocationAndWeatherWithData(locationData);
      
    } catch (e) {
      placeEl.textContent = "Location N/A";
      weatherEl.textContent = "Weather N/A";
      debugLog(`Complete failure: ${e.message}`);
    }
  }
  
  // Manual GPS injection for testing (open console and run: window.manualGPS = {lat: 32.7767, lon: -96.7970})
  window.injectGPS = function(lat, lon) {
    window.manualGPS = {latitude: lat, longitude: lon};
    debugLog(`Manual GPS injected: ${lat}, ${lon}`);
    updateLocationAndWeather();
  };
  
  // Setup everything
  setupLocationListeners();
  setInterval(updateLocationAndWeather, 90000);
  updateLocationAndWeather();
  
  // Debug information - extensive logging
  debugLog('IRL Pro GPS Overlay loaded with enhanced detection');
  debugLog(`User agent: ${navigator.userAgent}`);
  debugLog(`URL: ${window.location.href}`);
  
  const globalScan = scanGlobalScope();
  debugLog(`Global GPS-related objects: ${Object.keys(globalScan).join(', ') || 'none'}`);
  
  const domScan = scanDOMForGPS();
  debugLog(`DOM GPS data elements: ${domScan.length}`);
  
  // Log all interesting window properties
  const interestingProps = ['locationData', 'irlpro', 'streamingApp', 'gpsData', 'Android', 'webkit', 'GPS', 'gps'];
  interestingProps.forEach(prop => {
    if (window[prop]) {
      debugLog(`window.${prop} exists: ${typeof window[prop]}`);
    }
  });
  
  debugLog('Press Alt+D to toggle debug display');
  </script>
  </body></html>
