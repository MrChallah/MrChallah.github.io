<!DOCTYPE html><html><head><meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
<style>
html,body{margin:0;padding:0;background:transparent;color:#fff;font-family:sans-serif;}
#info{position:absolute;top:8px;left:8px;display:flex;flex-direction:column;gap:4px;}
.row{display:flex;align-items:center;font-size:15px;font-weight:500;text-shadow:0 0 4px #000,0 0 8px #000;}
.row i{width:18px;margin-right:6px;text-align:center;}
</style></head><body>

<div id="info">
  <div class="row"><i class="fa-regular fa-clock"></i><span id="time">--:--:--</span></div>
  <div class="row"><i class="fa-solid fa-location-dot"></i><span id="place">Waiting…</span></div>
  <div class="row"><i class="fa-solid fa-cloud"></i><span id="weather">--°C</span></div>
</div>

<script>
const placeEl = document.getElementById('place');
const weatherEl = document.getElementById('weather');
const OWM_KEY = '618628ae452ff89f0e4477fba20b9d5c';
const GOOGLE_GEO_KEY = 'AIzaSyBFwxZu_EqPgs7pEqk1uHn1f46F6vUoEFU';

function tick(){
  const now = new Date();
  const offset = now.getTimezoneOffset() / -60;
  const sign = offset > 0 ? '-' : '+';
  document.getElementById('time').textContent =
    `${now.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',second:'2-digit'})} GMT${sign}${Math.abs(offset)}`;
}
tick(); setInterval(tick, 1000);

async function reverseGeocode(lat, lon){
  const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en`);
  const geo = await res.json();
  const addr = geo.address;
  const parts = [
    addr.road || addr.suburb || "",
    addr.city || addr.town || addr.village || "",
    addr.state || "",
    addr.country || ""
  ].filter(Boolean);
  return parts.join(", ");
}

async function fetchWeather(lat, lon){
  const r = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&lang=en&appid=${OWM_KEY}`);
  const j = await r.json();
  const c = j.main.temp.toFixed(0);
  const f = (c * 9 / 5 + 32).toFixed(0);
  const desc = j.weather[0].description.replace(/\b\w/g, s => s.toUpperCase());
  weatherEl.textContent = `${c}°C | ${f}°F, ${desc}`;
}

// Enhanced IRL Pro location detection
function getIRLProLocation() {
  // Check common location property names
  const locationProps = [
    'locationData', 'gpsData', 'position', 'coordinates', 'location', 'gps',
    'currentLocation', 'deviceLocation', 'IRLLocation', 'streamLocation'
  ];
  
  for (const prop of locationProps) {
    if (window[prop]) {
      const data = window[prop];
      console.log(`Found window.${prop}:`, data);
      
      // Check different possible structures
      if (data.latitude && data.longitude) {
        return { lat: data.latitude, lon: data.longitude, source: `IRL Pro (${prop})` };
      }
      if (data.lat && data.lon) {
        return { lat: data.lat, lon: data.lon, source: `IRL Pro (${prop})` };
      }
      if (data.coords && data.coords.latitude && data.coords.longitude) {
        return { lat: data.coords.latitude, lon: data.coords.longitude, source: `IRL Pro (${prop}.coords)` };
      }
    }
  }
  
  // Check for potential IRL Pro functions
  const locationFunctions = ['getLocation', 'getCurrentLocation', 'getGPS', 'getPosition'];
  for (const func of locationFunctions) {
    if (typeof window[func] === 'function') {
      console.log(`Found function: window.${func}`);
      try {
        const result = window[func]();
        if (result && result.latitude && result.longitude) {
          return { lat: result.latitude, lon: result.longitude, source: `IRL Pro (${func}())` };
        }
      } catch (e) {
        console.log(`Error calling ${func}:`, e);
      }
    }
  }
  
  return null;
}

function getBrowserGPS() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation not supported'));
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          lat: position.coords.latitude,
          lon: position.coords.longitude,
          accuracy: Math.round(position.coords.accuracy),
          source: `Browser GPS (±${Math.round(position.coords.accuracy)}m)`
        });
      },
      (error) => {
        reject(error);
      },
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 30000
      }
    );
  });
}

async function getLocationFromGoogle(){
  const res = await fetch("https://www.googleapis.com/geolocation/v1/geolocate?key=" + GOOGLE_GEO_KEY, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ considerIp: true })
  });
  const data = await res.json();
  return {
    lat: data.location.lat,
    lon: data.location.lng,
    source: "IP Location"
  };
}

async function updateLocationAndWeather(){
  try {
    let locationData = null;
    
    // Try IRL Pro location data (enhanced detection)
    locationData = getIRLProLocation();
    
    // Try browser GPS if no IRL Pro data
    if (!locationData) {
      try {
        locationData = await getBrowserGPS();
      } catch (gpsError) {
        console.log('Browser GPS failed:', gpsError.message);
      }
    }
    
    // Fallback to IP location
    if (!locationData) {
      placeEl.textContent = "Using IP location...";
      locationData = await getLocationFromGoogle();
    }
    
    // Update display
    if (locationData) {
      placeEl.textContent = "Loading location...";
      const label = await reverseGeocode(locationData.lat, locationData.lon);
      placeEl.textContent = label;
      fetchWeather(locationData.lat, locationData.lon);
      console.log(`${locationData.source}: ${locationData.lat}, ${locationData.lon}`);
    }
    
  } catch (e) {
    placeEl.textContent = "Location N/A";
    weatherEl.textContent = "Weather N/A";
    console.error("Failed to get location or weather:", e);
  }
}

setInterval(updateLocationAndWeather, 10000);
updateLocationAndWeather();
</script>
</body></html>
